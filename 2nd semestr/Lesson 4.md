# Строки

``` c

char *s;
char *p
s = (char *) malloc(n);
p = (char *) malloc(n);
s[0] = 0;
*p = '\x0';
strcat(s, p);
```

Аналогично в питоне

``` python
a = ''
b = ''
s = a + b

```

### Увеличение длины строки

``` c
char *s;
char *p;
p = (char*) malloc (n + x);
p[0] = 0;
strcpy(p, s);
free(s);
```

Это то же самое что realloc

``` c
s = realloc(s, n + x);
```

В питоне всё это автоматически
`s += b`

### Функции библиотеки <string.h>

`strlen(s)` - длина

`strcopy(s, p)` - копирование из p в s

`strcpy(s, p, n)` - копирование из p в s не более n первых символов

`strcat(S, p)` - приклеить p к s

`srtcat(s, p) = strcpy(s + strlen(s), p)` - одно и то же

``` c

*s = 0;

strcat(s, p);

```

это был strcpy

`strncat(s, p, n)` - приклеить p к s не более n первых символов

`strcmp(s, p)` - сравнение строк. Если s < p, то strcmp(s, p) < 0. Лексикографическое сравнение

`strncmp(s, p, n)` - то же самое, только первые n символов

`strchr(s, x)` - поиск символа x в s. Возвращает указатель на первое вхождение.

Чтобы получить индекс, нужно вычесть указатели: `int(x - s)`

Если не найдено вхождений, то `strchr(s, x) == NULL`

'strrchr(...)' - поиск с конца

`strstr(s, p)` - поиск строки p в s. Возвращает указатель на первое вхождение.

'strrstr(...)' - поиск с конца

`strtok()` - что-то делает

``` c

char s[1000];

sprintf(s, "%d", x);
// число в строку

sprintf(s, "x=%d, ...", x);
// числа в строку

snprintf(s, n, "x=%d, ", x, y, x, ...);
// n символов в строку s

sscanf(s, "%d", &x);
// считывание из строки в число

```
# Указатели
``` c
int *a
a = (int*) malloc(n * sizeof(int));
```
Указатель на первый элемент массива, выделено какое-то количество памяти на наш массив.
gcc -32
Указатель будет 4х байтовым. На компе возможно хранить только ~4 гига памяти, т.к. возможно только ~400млн адресов
gcc -64
Указатель будет 8ми байтовым

*(a + 5) = a[5]
*(a + 3 + 2) = (a + 3)[2]
*(5 + a) = 5[a]
*(a + 0) = a[0]
Вот почему массив нумеруется с 0!
Можно начинать массив и с 1
`int *b = a - 1;`

### Арифметика указателей
``` c
int *a;
a + 1; 
// прибавим 4 байта, но сместим ячейку на 1 ячейку
// поэтому важно указать тип указателя, чтобы комп знал на сколько байт смещать указатель
```

``` c
int *a;
char *b;
b = a;
b = b + 1;
a = b;
// теперь мы смогли сместить на 1 байт, хоть это и незаконно для int
```
`void *b` - для него арифметика не работает, но он существует
Операции | Существование +/-
a + 1    |  +
a - 1    |  +
a + n    |  +
a - n    |  +
a * k    |  -
a / k    |  -
a + b    |  -
a - b    |  +
Последнее возможно, так как a + n = b, значит a - b = -n. Выдаст разность в кол-ве ячеек.

Как найти произведение указателей?
``` c
int *a, *b;
int d, f;
d = (int) a; b = (int) f;
a = (int*) (d * f);
```

# Строки
char * s;
char s[100]
char -> 1 byte

\0 особая буква, означающая конец строки
Если этой метки не будет, то можно легко выйти за рамки массива/строки

Русские кодовые таблицы:
koi8r
win-1251

Нормальные кодовые таблицы:
utf-8
utf-16

``` c
char s[100];
s[0] = '\0'; // правильная структура создания массива символов

s[0] = 'B';
s[0] = s[0] - 'A' + 'a'; // 'b'
```


``` c
char *s;
s = (char*) malloc (n * sizeof(char));
s[0] = 'A'; s[1] = 'B';
printf("%s", s);
```

посчитаем длину строки:
``` c
int sringlength(char* s){
    int i = 0;
    while (s[i] != '\0') i++;
    return i;
}
```

Копирование строки:
``` c
int sringcopy(char* s, char * s1){
    while (*s++ = *s1++);
}
```









